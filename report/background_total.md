# Background

To play the four-player Bomberman game, we use a type of machine learning called Reinforcement Learning (RL). RL is a learning paradigm in which an agent (the decision-maker) interacts with an environment (in this case, the Bomberman game, which consists of a board, walls, crates, bombs, coins, and other agents) to maximise its long-term cumulative reward. The agent chooses from a set of possible actions - moving up, down, left, right, dropping bombs, or waiting - and receives a reward based on the outcome of the action taken in a given state.

To formalise this sequential decision process and make it solvable using RL algorithms, we model the Bomberman game as a Markov Decision Process (MDP). This allows us to formulate the problem in terms of states, actions, rewards and transitions. The state provides the agent with all the necessary data to describe its current situation, such as the round, the number of steps, the contents of each tile on the board (e.g. coins), the countdown to the explosion of placed bombs, and which coins are collectible.

As for actions, we have already listed all the possible moves an agent can make. The policy is the strategy that defines which action to take in a given state. The agent's goal is to learn an optimal policy π∗\pi^*π∗ that tells it the best action to take in each possible state to maximise the cumulative rewards over time. Reward shaping plays an important role in accelerating training. In Bomberman, reward shaping is possible through a list of game events stored in the events.py file. By assigning auxiliary rewards to certain events, we can guide the agent to learn faster. However, we need to be careful. Improper reward shaping (e.g. excessive rewards for trivial tasks) can cause the agent to converge to suboptimal behaviour. Positive rewards could be given for collecting coins, eliminating enemies and surviving bomb explosions, while penalties could be given for being killed or accidentally killing oneself.

Another component of the MDP is the transition function T, which defines how the game environment changes in response to an action. For example, if the agent moves left, the transition function will update the agent's position on the board, and if the agent drops a bomb, the game state will reflect that a bomb has been placed, with an explosion occurring after a certain number of time steps.

To help the agent learn the best actions in different states, we need a way to estimate how good each state-action pair is. This is where Q-learning comes in. Q-learning is a popular RL algorithm that uses a Q-function Q(s,a) to estimate the expected return for taking action a in state s. The Q-function represents the value of taking action a in state s and following the current policy thereafter. Over time, as the agent explores the game environment, the Q-function is updated using the Bellman equation. Through iterative updates, the agent refines its Q-values for each state-action pair it encounters. When training is complete, the agent can simply choose the action with the highest Q-value in each state, corresponding to the optimal policy π∗\pi^*π∗.

In Bomberman, the number of possible states can be extremely large due to the various configurations of agents, bombs, crates Instead of encoding positions of all objects, we can focus on key high-level features that are relevant for decision making. This not only reduces the dimensionality of the state space, but also preserves critical information that the agent needs to act effectively.

One important feature is the display of blocked squares around the agent (top, right, bottom, left). This feature indicates whether each of the four directions is blocked by a wall or crate. Each direction can take a binary value, where 1 means the direction is blocked and 0 means it is not blocked. This feature gives the agent immediate awareness of its local environment, so it knows where it can and cannot move.

Another critical feature is the explosion map, which tells the agent whether a bomb is expected to explode in one of four directions. A value of 1 indicates that the direction is within the explosion range of a bomb, while 0 indicates otherwise. The explosion map helps the agent to prioritise avoiding danger and moving to safe squares.

The direction to the nearest coin, crate or safe square is also important. These features encode the direction of nearby important objectives. Coins are valuable collectibles that the agent should prioritise, while crates are destructible and can hide coins, requiring strategic bomb placement. Safe squares are locations outside the explosion radius of bombs and are critical for survival. The direction is coded as follows 0 means there is no coin/crate/safe square nearby, 1 means the coin/crate/safe square is above (top), 2 means it is to the right, 3 means it is below (down) and 4 means it is to the left. This abstraction reduces complexity by ignoring distant coins or crates that are less relevant to the agent's immediate decision process.

Combining these features dramatically reduces dimensionality compared to encoding the entire grid. The blocked squares feature consists of 4 indicators (top, right, bottom, left), each taking values of 0 or 1, resulting in 16 possible configurations. The explosion map also has 4 indicators (top, right, down, left) giving another 16 possible configurations. The direction to the nearest coin/crate/safe square has 3 indicators, each taking values from 0 to 4, resulting in 125 possible configurations. So the total number of possible state configurations based on this feature set is 16 times 16 times 125, or 32,000 possible state configurations. This number is significantly smaller than encoding the entire grid, making it more feasible for the agent to learn from experience.

To further reduce the number of states the agent has to learn, we can introduce a permutation function that exploits the rotational symmetry in the environment. The idea is to rotate the agent's perception of the environment so that it always sees an unblocked direction as "up". This simplification reduces the number of different states the agent has to consider, allowing it to generalise better by treating symmetrical situations as equivalent.

If only one direction is unblocked, the agent can rotate the environment so that this direction becomes "top". If two or more directions are unblocked, the agent can rotate until the first unblocked direction (in clockwise order) becomes "top". For example, if the top and left directions are blocked, and the right direction is in the explosion map, the agent can rotate its perspective so that the unblocked direction (in this case, "bottom") becomes "top" in its new frame of reference. This technique allows the agent to focus on learning from fewer different scenarios, improving training efficiency. By exploiting these high-level features and symmetry in the environment, we can effectively manage the complexity inherent in the Bomberman game, while still allowing the agent to learn optimal strategies for successful gameplay.

Instead of explicitly storing entries for each state-action pair, we approximate Q-values using Deep Q-Networks (DQN). This approach allows the agent to generalise across similar states by recognising patterns, which facilitates better decision making in previously unseen states. DQNs can capture complex relationships between states and actions that may not be easily represented in a Q-table. For example, if the agent has to navigate between multiple goals - such as avoiding explosions while collecting coins - a DQN can prioritise actions more effectively.

The DQN architecture consists of multiple layers of neurons, with the input layer receiving processed features (e.g. blocked squares and explosion maps) and the output layer producing Q-values for each possible action. This structure allows the agent to generalise its knowledge, rather than learning each state-action pair independently.

To increase learning stability, DQNs implement an experience replay buffer that stores past experiences (combinations of state, action, reward, and next state). During training, the agent randomly samples experiences from this buffer, breaking the correlation between consecutive samples and allowing for a more diverse set of experiences. In addition, DQNs update their weights using a loss function based on the difference between predicted Q-values and target Q-values, computed using the Bellman equation. The loss is minimised using gradient descent, allowing the network to iteratively refine its Q-value approximations.
